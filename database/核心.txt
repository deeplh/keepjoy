数据库范式
第一范式:列的原子性,值不能重复,不能再分割.
举例:电话可以再分成家庭电话和移动电话,不符合

第二范式:所有的非主属性都完全依赖于关键字(只能有一个主键,一个表只做一件事).
举例:学号,姓名,年龄,课程名称,成绩,学分
(课程名称) → (学分),(学号) → (姓名，年龄),做了两件事,两个主属性,不符合

第三范式:每一个非主属性既不部分依赖于也不传递依赖于关键字,也就是在第二范式的基础上消除传递依赖
举例:姓名,年龄,所在学院,学院地点,学院电话
(学号) → (所在学院) → (学院地点,学院电话)
因为非主属性 所在学院 能得到 学院地点,学院电话 所以不符合

BC范式:第三范式的基础上进一步消除主属性对于部分函数依赖和传递依赖(不能存在关键字决定关键字的情况)
举例:仓库ID,存储物品ID,管理员ID,数量  且有一个管理员只在一个仓库工作；一个仓库可以存储多种物品
(仓库ID) → (管理员ID),(管理员ID) → (仓库ID)  出现了关键字决定关键字的情况,不符合


for update 锁
当开启事务后一个查询用了for update后，事务不提交的话，另外一个for update 如果查询的是一条语句则会阻塞
7个传播机制
1.REQUIRED:如果当前事务上下文中存在事务，则使用当前事务，否则新建一个事务
2.SUPPORTED:如果当前事务上下文中有一个事务，那么使用上下文中的事务；如果没有，那么按照没有事务的方式执行
3.NOT_SUPPORTED:无论当前事务上下文中有没有事务，都会按照无事务的方式执行
4.REQUIRES_NEW:无论当前事务上下文中有没有事务，都会开启一个新的事务
事务间没有依赖关系，四种情况都有可能出现
A成功B失败，A失败B成功，A成功B失败，A失败B失败
5.MANDATORY:如果当前事务上下文中有一个事务，那么使用事务上下文中的事务;如果没有，那么抛出一个IllegalTransactionStatException
6.NEVER:如果当前事务上下文中有一个事务，就会抛出IllegalTransactionStatException
7.NESTED:在当前事务上下文的事务中增加一个保存点，如果内嵌事务发生回滚，只会回滚内嵌事务，不会回滚外层事务
与REQUIRES_NEW的区别是，内嵌事务信赖A, 不可能出现A失败B成功

4个隔离级别
Read Uncommitted（读取未提交内容）一个事务可以都到另一个事务没有commit的数据
Read Committed（读取提交内容）一个事务只能读到另一个事务已经commit的数据，但是只要另外一个事务commit了，本事务再次读取时就是新的了，所以无法重复读
Repeatable Read（可重读）一个事务，读取一次数据后，另一个事务无论修改并commit后，本次事务再次读取的还是第一次读取的数据，但是当另外一个事务做insert操作时，就会出现幻想读
Serializable（可串行化）强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争

共享锁(S):允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。
排他锁(X):允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁

InnoDB行锁是通过给索引上的索引项加锁来实现的，因此InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！
在事务中，只有SELECT ... FOR UPDATE 或LOCK IN SHARE MODE 同一笔数据时会等待其它事务结束后才执行，对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)。

使用select…for update会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认Row-Level Lock，
所以只有「明确」地指定主键（或有索引的地方），MySQL 才会执行Row lock (只锁住被选取的数据) ，否则MySQL 将会执行Table Lock (将整个数据表单给锁住)。


乐观锁
数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，
如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。
